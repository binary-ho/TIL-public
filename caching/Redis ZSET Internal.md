# Redis ZSET Internal
Redis ZSET을 구성하는 2가지 자료구조 Zip List, Skip List에 대해 간단하게 알아보자. <br> 
딱 2개만 분명히 머리 속에 넣어두면 될 듯
1. 두 자료구조의 아이디어와 시간복잡도 등
2. Redis에서 왜 두 자료구조를 골랐는지
 
<Br>

Skip List 코드는 옛날에 짜봤으니 Pass 오늘은 이론만. <br> 
-> [golang skip list](https://github.com/binary-ho/golang-data-structure/tree/main/skip)

# 1. ZSET
Redis ZSET은 우선순위 대로 값이 정렬된 SET이다. <br>
Key와 Score라는 Value로 저장할 수 있는데, 이 Score가 정렬의 기준이 된다. <br>
간편하게 범위 검색도 할 수 있고, 어떤 맴버가 몇번째 위치에 있는지 쿼리할 수 있다. <br>
이런 점들을 활용해 있는 그대로 Set 이상으로 활용할 수 있다. 실시간 랭킹 계산이나, 정렬된 결과를 DB에서 조회할 때의 캐시로도 쓸 수 있다. <br> 
매우 빠른 시간 복잡도를 보장하는데, **key나 socore로 접근하는 경우 O(1), index로 접근하는 경우 O(log(N))을 보장한다. index는 곧 순위임으로 순위를 쿼리할 때도 logN이다.** <br> <br>

- 삽입: O(log(N))
- 조회: O(1) -> key, score로 조회
- 범위 조회: O(log(N) + M):
- 범위 삭제: O(M*log(N)) -> M개를 지울 때, M번의 log(N) 삭제를 수행한다.
- 랭크 검색: O(log(N))

<br>

**이런 빠른 시간복잡도를 가질 수 있는건 Skip List 덕분이다.**

## 1. ZSET 내부 자료구조
**ZSET은 맴버 갯수와 데이터 크기에 따라 2개의 자료구조를 활용한다.**

1. Zip List: `맴버 128개 이하` && `Value 크기 64 Byte 이하`인 경우
2. **Skip List**

<br>

Java HashMap의 treeify 처럼, 처음엔 Zip List를 사용하다가, 맴버 갯수가 128개가 넘어가거나, Value값이 하나라도 64 Byte를 넘어가게 되면 Skip List로 변경된다. <br>

두 자료구조를 알아보고, Redis에서 선택한 이유를 알아보자. 고고씽

## 2. Zip List

### 2.1 메모리 기반 저장소 Redis와 Skip List
- `Skip List의 문제`: Skip List는 빠른 시간복잡도를 보장하지만, 메모리를 더 사용한다. <br> 이 자료구조를 비유하자면 여러 층을 가져 어느 정도 데이터의 중복이 있는 버전의 Linked List인데, 데이터 갯수보다 노드가 많을 수 있고, 또 링크드 리스트를 구성하기 위한 기본 오버헤드들 때문에 데이터가 적을 때는 이 자료구조를 유지하기 위한 용량이 더 클 수도 있다. <br> **시간복잡도를 조금만 포기하면 데이터를 더 아낄 수 있는 여지는 있다.** <br> <br>

- `Redis의 미션`: **Redis는 메모리에 데이터를 저장하는 캐싱 라이브러리로 비싼 자원인 메모리를 최대한 조금 쓰는 것이 중요한 미션이다.** <br>
**따라서, 맴버 갯수가 적을 때는 어차피 다른 자료구조를 써도 연산 시간이 그리 느리지 않으니, 용량에 초점을 맞춘 Zip List를 쓰자는 아이디어.** <br>

### 2.2 Zip List 구조
**Zip List는 최소한의 메모리를 사용하는 것에 특화된 List이다.** <br>

List라고 하면 보통은 다음 데이터가 저장된 노드를 가리키는 포인터가 있기 마련인데, 그 포인터를 사용할 용량도 아낀다.

![Image](https://github.com/user-attachments/assets/16e348a5-f122-442e-a835-1d4a9aa475b6)

<br>

Zip List는 이전 데이터의 길이 `prevlen`과 자신의 길이 `itself len` 그리고 저장할 데이터인 value를 가지고 있다. **이렇게 길이 정보를 알고 있기 때문에 포인터가 없어도 앞, 뒤 노드를 탐색할 수 있다.** <br>
시간복잡도는 기존 List와 같이 원소마다 길이 정보를 확인하고, 다음/이전 노드를 탐색해 하나씩 탐색하므로 O(N)이다..
<br> <br>

![Image](https://github.com/user-attachments/assets/41dbc0eb-0018-4e5a-8400-13f6a3b25524)

자료구조 전체로는 위와 같은 노드 하나 -> "엔트리"들을 효율적으로 관리하기 위해 추가적인 값들을 관리한다.


1. `zlbytes`: 총 바이트 수
2. `zltail`: 마지막 엔트리 시작 byte
3. `zllen`: 총 엔트리 갯수
4. `zlend`: Zip List 끝 경계

<br> 

64 Byte 제한이 있으니까, 사실상 수 bit 안에 용량 표현이 가능할 것이고, redis가 구현된 c에서 pointer는 64bit 기준 8 Byte정도 하니까, pointer가 있는 자료구조들 보다 더 작은 용량을 차지하는게 맞다. <br>

아무튼 맴버 갯수 128개와 그 근처까지는 O(N)이여도 충분히 빠르니 zip list를 쓰는 것이고, 이후부터는 skip list로 구조가 변경된다. <br>


## 3. Skip List

스킵 리스트는 아래와 같이 생긴 자료구조이다. 

![Image](https://github.com/user-attachments/assets/9ed44c21-b1fc-4247-a2ca-a80690f58a8a)

<br>

리스트는 리스트인데, 여러 층으로 구분되며, 노드들마다 층이 다르다. -> **레벨을 가진 노드를 만들고 높은 레벨일 수록 적은 노드를 배치해 Log 탐색할 수 있는 아이디어** <br>
위 자료구조를 활용해 탐색하면 이분탐색을 할때 처럼 효율적인 Log 시간복잡도 탐색이 가능하다. 위 그림에서 30을 찾을 때 어떤일이 일어나는지 생각해 보자. <br> <br>

그림에서 가장 윗 층의 왼쪽 끝에서 시작한다고 생각해 보자. 가장 윗 층은 "70"만이 저장되어 있다. <br> 
1. 먼저 "30"가 70보다 작은지 큰지 확인하게 된다. 70보다 작다면 한층을 내려가 다시 탐색하고, 70보다 크다면 오른쪽으로 한칸 이동해 70과 다음 숫자를 비교할 것이다. (그림에서 다음 숫자는 없지만)  <br>

2. 아무튼 30은 70보다 작으므로 한칸 내려가게 된다. 왼쪽 끝 노드의 위에서 2번째 층에서 탐색한다. 
3. 다음 노드는 20을 가리키고 있는데, 25는 20보다 크니까 오른쪽으로 한칸 이동한다.
4. 이제 20 노드의 가장 윗 층에 있다. 다음 노드는 70이므로, 오른쪽으로 이동하지 말고 한칸 내려가야 한다.
5. 이제 20 노드의 위에서 2번째 층에 있다. 다음 노드는 27을 가리키고 있는데, 30보다 작으니까 오른쪽으로 한칸 이동한다
6. 이제 27 노드의 가장 윗층에 있다. 27노드의 가장 윗층의 다음 노드는 70이다. 30은 70보다 작으므로 한칸 내려간다
7. 이제 27노드의 가장 아랫층에 있다. 다음 노드는 30이므로 발견했다.

<br> <br>

마치 이분탐색처럼 log 시간복잡도로 노드를 찾을 수 있다. <br>
따라서 O(logN)의 시간복잡도만에 삽입/삭제 연산시 적절한 위치를 찾을 수 있다. key나 score로의 조회는 더 빠르다 내부 dict 자료구조로 O(1)면 된다.

<Br>

### 3.1 Indexed Skip List
정렬된 List나 Tree형태의 자료구조에서 어떤 노드가 "몇번째 노드인지"는 바로 알기 어렵다. <br>
이를 빠르게 세기 위해 이 Indexed Skip list에서는 **현재 가리키고 있는 다음 노드가 몇번째의 노드인지만 저장한다.** 이 값을 `SPAN`이라고 하며, 위 그림에서 포인터 옆에 적힌 값이다. <br>
**그래서 redis에서의 skip list는 정확히는 indexed skip list이다.** <br> 
**저 숫자들을 이용하면 인덱스로도 빠르게 데이터를 찾을 수 있는 것이다**

<br> <br>

![Image](https://github.com/user-attachments/assets/b36d77a5-3067-48b6-8a6c-c66ce4b2a113)

위 그림에서 "20"은 몇번째 값인가? 눈으로 보면 4등이다. <Br>
이를 계산하기 위해 아래와 같이 탐색한다.
1. 첫 노드 가장 윗층에서 다음 노드는 25니까 한칸 내려간다. 이후 다음 노드가 18이니까 이동하는데, 저장된 SPAN값인 3을 센다.
2. 다음 노드 18에서 또 한칸 내려간 다음 이동하는데, 이때의 SPAN 값은 1이다.
3. 3 + 1 -> 4이다. 20 노드는 Skip List에서 4번째 값이다

### 3.2 삽입은 어떻게 이루어지는가?
- 문제상황
  - 각 노드의 레벨을 skip list의 상황과 무관한 어떤 값으로 결정해야 한다.
  - 높은 층으로 갈 수록 적은 데이터가 저장되어야 한다.
- **해결: 그럼 랜덤으로 정하자** 
  - **주사위를 던져 같은 숫자가 연속으로 나오면, 연속으로 나온 횟수만큼 층을 높인다**
  - 이렇게 하면 자연스럽게 높은 층일 수록 데이터가 조금 저장될 것이다. 또한 Skip List의 전체 상황과 무관하게 층들이 결정된다.

<br>

메릴랜드 대학 교수 윌리엄 퓨는 최적의 주사위를 찾기 위해 실험을 했다. <br>

원하는 것은 다음과 같다.

1. 탐색 시간이 빨라야 한다.
2. 노드당 평균 레벨이 너무 높지도, 너무 낮지도 않아야 한다.

![Image](https://github.com/user-attachments/assets/34bf483d-b285-48c0-bdd6-edebdb77d525)


확률별로 탐색 시간과 노드당 평균 레벨을 계산해봤다. <br>

탐색시간 적으로는 1/e가 가장 빨랐지만, 탐색시간 상위 3개 확률 중 **1/4일때 노드당 평균 레벨이 가장 낮고, 1/e와도 큰 차이가 없으므로, 1/4를 선택했다.**


<br>

이제 1 ~ 4까지 있는 주사위를 던져서 같은 숫자를 뽑을 때마다 한 층씩 높아진다. <Br> <br>


문제가 있다. 극단적으로 층이 너무나도 높아지면 어떡할 것인가?

### 3.3 :star: 확률적 요소가 있는 자료구조를 쓰는게 맞아?

이 문제를 해결하기 위해 높이에 제한을 두었다.
- 최대 레벨은 32로 정해졌다.
이 숫자까지 닿을 확률은 극히 낮고, 정말 극단적인 경우를 방어하기 위해 설정됐다.


### 3.4 레디스에서의 실제 구성
글 쓰다보니 지쳐서 일단은 간단하게 백지복습 하고 나중에 채워야겠다. <br>

![Image](https://github.com/user-attachments/assets/6a7865bf-6be6-4c08-9cb0-84b90c7a37b6)


#### Redis의 Skip List가 일반적인 Skip List와 다른 점
1. 같은 Score 허용
2. back pointer로 역 탐색 가능 (정확히 언제 쓰는거지)
3. **최대 레벨 32**
4. Skip List 자체를 저장하는 구조체에 최대 레벨, 노드 수, 헤더 노드, Tail Node등의 포인터를 가지고 있다.
5. 명시적인 데이터 저장 갯수 제한 없음


## Reference
- [Redis 연산들 문서](https://redis.io/docs/latest/commands/zscore/)
- [Redis sorted sets](https://redis.io/docs/latest/develop/data-types/sorted-sets/)
- [레디스 게이트 - Redis SKIP List of  ZSETS (SORTED SETS)](http://redisgate.kr/redis/configuration/internal_skiplist.php)
- [[Redis] ZSet, Hash, List는 왜 내부적으로 zip 리스트를 사용할까?](https://bugoverdose.github.io/posts/85/)
