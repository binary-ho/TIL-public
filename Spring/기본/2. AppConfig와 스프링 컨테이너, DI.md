
## AppConfig
AppConfig의 도입으로 사용 영역과, 구성 영역의 구분이 가능해진다. 극의 배우들은 자기 연기만 연습 잘 하면 된다. 상대 배우가 누구일지는 신경 안 써도 된다. (사용 영역) <br> 어떤 배우를 어떤 배역에 줄지 **구성** 하는 역할은 공연 기획자가 알아서 다 해준다. **이런 구성 역할을 해주는 것이 바로 AppConfig다.** 


# IoC, Di, 그리고 컨테이너
## 1. 제어의 역전 IoC - Inversion of Control
제어의 역전! <br>
AppConfig 도입 전, 기존의 프로그램은 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고, 연결하고, 실행한다. **구현 객체가 프로그램의 제어 흐름을 스스로 조종했다.** 사실은 이것이 개발자 입장에서는 자연스러운 흐름이 맞다! 

<br> 

반면 AppConfig의 등장 이후엔, **구현 객체는 오직 자신의 로직을 실행하는 역할만 담당한다.** <br> **프로그램의 제어 흐름은 이제 AppConfig가 관리하는 것이다.** 프로그램의 제어 흐름 권한은 모두 AppConfig가 가져간다. 이제, 다른 구현 객체들은 자신에게 필요한 인터페이스들을 호출하지만, 어떤 구현 객체들이 실행되는지는 모른다!

<br>

이렇게, 프로그램의 제어 흐름을 직접 제어하는 것이 아니라, 외부에서 관리하는 것을 **제어의 역전 IoC라고 부른다.** 
<br> 내가 작성한 코드를 남이 대신 제어하고, 대신 실행해주면? -> 프레임 워크 
<br> 내가 작성한 코드가 직접 제어의 흐름을 담당한다면? -> 라이브러리 


## 2. DI - 의존 관계 주입 (Dependency Injection)
애플리케이션 실행 시간에 외부에서 실제 구현 객체를 생성하고, 클라이언트에 전달해서 클라이언트-서버의 실제 의존관계가 연결 되는 것을 **의존관계 주입**이라고 한다. -> 객체 인스턴스를 생성하고, 그 참조값을 전달해서 연결된다. 
<br> 

이런 식으로 의존관계 주입을 해주면, 클라이언트 코드를 변경하지 않고도, 호출하는 대상의 타입 인스턴스를 변경할 수 있다. -> **정적인 클래스 의존관계 변경 X, 동적인 객체 인스턴스 의존관계를 변경 가능!**

## 3. IoC 컨테이너, DI 컨테이너
**AppConfig처럼** 객체를 생성하고 관리며 의존관계를 연결해 주는 것을 IoC 컨테이너 또는 **DI 컨테이너**라고 부른다. 어플리케이션 전체에 대한 구성을 조립하므로, 어셈블러, 오브젝트 팩토리 등으로 불리기도 한다.

## 4. 스프링 컨테이너
`ApplicationContext`를 스프링 컨테이너라고 부릅니다. <br>
AppConfig가 도입된 이후, 개발자는 AppConfig를 이용해서 객체를 생성하고 의존성 주입을 했었지만, 이제는 스프링 컨테이너를 통해서 사용합니다. <br> <br> 
- AppConfig에 `@Configuration`를 붙여 스프링에게 이것을 설정 정보로 사용하라고 알려줄 수 있습니다. 스프링은 `@Bean`이 붙은 메서드를 모두 호출해서 반환된 객체들을 **스프링 빈**으로 전부 스프링 컨테이너에 등록합니다. <br> 
- 스프링 빈은 `@Bean`이 붙은 메서드의 이름을 스프링 빈의 이름으로 사용합니다. 필요한 스프링 빈(객체)를 가져올 때는 `applicationContest.getBean()` 메서드를 사용해서 찾을 수 있습니다. 


**그럼 대체 뭐가 좋은걸까요?** 결국 AppConfig에서 필요한 객체들을 찾아내나, 스프링 컨테이너에서 필요한 스프링 빈을 찾아내나 결국 똑같은데 코드만 더 복잡해진 것 아닌가요? -> 이제 알아보자 ㅋ
