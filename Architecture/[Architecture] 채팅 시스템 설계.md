# 채팅 시스템 설계

오늘은 "가상 면접 사례로 배우는 대규모 시스템 설계 기초" 책을 통해 간단한 채팅 시스템 설계 방법을 알아보았다. <br>
해당 챕터에는 매우 거대한 대규모 채팅 서버의 설계 방식에 대한 내용이 나와 있지 않다. <br>
그리고 책이 옛날 책이여서 그런지 최신 기술들을 접목한 설계 방식이 딱히 나와 있지 않은 것 같다. <Br>
일단 간단하게 학습한 내용만 정리하고, 더 큰 트래픽에서의 채팅 서버 설계는 다음에 직접 찾아보자.

<br>

# 1. 명세
이 책은 시스템의 설계 과정을 보여주기도 하지만, 면접 과정에서의 팁도 많이 알려준다. <br>
"채팅 시스템을 설계해 보세요"라는 질문이 들어왔다면, 먼저 대화를 통해 요구되는 기능들을 확정해 나가야 한다. <br>

1. 1:1 채팅 기능이 있나요? (카카오톡, WhatsApp 등)
2. 그룹 채팅 기능이 있나요? (Slack, 카톡 단체 톡방)
  - 인원 제한이 있나요? 
3. 대규모 음성 채팅 기능이 필요한가요? (디스코드, 카톡 그룹 통화 등..)
4. 모바일인가요 웹 앱인가요?
5. 처리해야 하는 트래픽 규모는 어떻게 되나요?
6. 첨부 파일 첨부가 가능한가요?
7. 채팅 이력은 얼마나 보관하나요?

<br>

등등 요구되는 기능들을 분명히 해두고 시작해야 한다.

<br>

이 책에서 주어진 채팅 시스템의 명세는 아래와 같다
### 명세
1. 응답 지연이 낮은 **1:1 채팅 기능**
2. 최대 100명 참여 가능한 **그룹 채팅 기능**
3. 접속 상태 표시 가능
4. **다양한 단말 지원,** 하나의 계정으로 여러 단말 동시 접속 지원
5. 푸시 알림
6. 5천만 DAU (능동 사용자 수) 처리 가능


# 2. 서버 구현
보통 클라이언트끼리는 직접 소통하지 않는다. 중간에 채팅 서버를 끼고 소통한다. <br> 
채팅 서버는 아래와 같은 기능들을 가지고 있어야 한다. <br> <br>

1. 클라이언트들로 부터 메시지 수신 가능
2. 메시지 수신자를 결정 가넝
3. 메시지 수신자에게 메시지 전달 가넝
4. 상대방이 접속 상태가 아닌 경우, 접속할 때까지 메시지들을 보관 가능

<br>

이러한 서버가 메시지를 송신하는 시나리오는 쉽다. <br>
연결을 어느정도 유지할 수 있는 방식으로 연결하면 되는데, HTTP와 같은 프로토콜로 메시지를 송신 받으면 된다. <br>

문제는 수신시 시나리오이다.

## 2.1 메시지 수신 시나리오
서버가 먼저 클라이언트에게 메시지를 전달하는 것은 쉽지 않다. <br> 
서버가 클라이언트에게 HTTP 메시지를 먼저 보내는 것은 쉽지 않은 노릇이다. <br>
마치 서버가 연결을 만드는 것처럼 동작할 수 있도록 하기 위해, polling, long polling, WebSocket 등의 기법이 제안되었다.

## 2.2 폴링
CS에서 Poll은 주로 데이터를 끌어오는, 가져오는 경우에 쓰인다. (ex. Queue Poll) <br>
Polling은 말 그대로 주기적으로 서버에게 새 데이터가 있는지 확인해서 가져오는 것이다. <br> 

아래 사진은 우리 옛날 옛적 네이버 실시간 랭킹 사진이다. 잘 기억은 안 나지만 화면을 보고 있으면, 한번씩 랭킹 내용이 변했었는데, 이러한 실시간 랭킹은 보통 폴링으로 구현 했다고 한다. 

<br>

![image](https://github.com/10000-Bagger/free-topic-study/assets/71186266/42e20d0b-74a7-432f-b7c5-6e441ad32d92)

<br>

(썰 : 네이버 실시간 검색어 폴링 방식이 유저들에게 조작 의혹을 심어준다는 주장도 있다. [링크](https://www.kiso.or.kr/wp-content/uploads/2014/10/3%EC%B0%A8-%EA%B2%80%EC%A6%9D%EB%B3%B4%EA%B3%A0%EC%84%9C.pdf))

<br>

폴링은 그 주기가 중요한데, 폴링 주기가 너무 길면, 폴링 주기 사이에 온 메시지들을 바로 받아 보기가 어렵다. <br>
그렇다고 폴링 주기가 너무 짧으면, 새로운 메시지도 없는데 쓸대없이 계속 데이터를 확인하게 된다. <br> <Br>
폴링 주기는 어떻게 잡아도 애매하다. 카톡이 하루종일 오는 인싸들도 있지만, 아싸인 나는 연락이 오지 않는다. <br>
하지만 받을 메시지도 없으면서 눈치도 없이 계속 서버에 데이터를 요청하니, 서버는 속이 터질 것이다. <br> <br>


## 2.3 롱폴링
롱폴링의 경우 기존 Polling의 비효율을 개선하기 위해 등장했다. <br>
기존 폴링은 서버측에 데이터가 있던 없던, 질의 이후 연결을 종료했다면 롱 폴링은 타임아웃이 발생하기 전까지, 새 데이터를 기다린다. 
그리고 새로운 데이터가 있는 경우 연결을 다시 한다. 

<br> <Br>

바로 연결을 끊지 않고, 조금 기다려 주는건데.. <br>
썩 괜찮은 방법 같지만, 몇 가지 약점이 있다.
1. 메시지가 연결을 유지중이지 않은 서버에 도착할 수도 있다. <br> -> 채팅 서버가 여러대이고, 로드밸런싱 중인 경우 발생할 수 있다. 그러니까 나는 A 서버와 연결을 맺고 있는데, B 서버에 도착할 수도 있다는 것.. (DB에 폴링하면 되지 않나?)
2. 서버 입장에서는 클라이언트의 연결 해제 여부를 알 수 없다. (왜 그런지 이해 못함)
3. 아직도 비효율적이다 -> 메시지를 거의 받지 않는 아싸 유저도 타임아웃이 일어날 때마다 계속 재연결 할텐데, 받을 일도 없는데 참 손해이다.

<br> 

결국 폴링은 메시지가 없을 때도 주기적으로 질의한다는 문제를 해결하지 못했다.  <br>
이게 제일 큰 문제인데 말이다.. <br>
그래서 어찌해야 하냐? 결국 '연결'이다. 결국 클라이언트와 서버를 연결 해서 실시간으로 데이터를 주고 받는게 최고다. <br>

## 2.4 웹소켓
<br>

![image](https://github.com/10000-Bagger/free-topic-study/assets/71186266/a40df528-bff2-4f17-b769-b226f2656b9e)

이제 우리가 기다리던 웹소켓의 시간이 왔다.  <br>
웹소켓으로 한번 이어진 연결은 항구적이며(변하지 않고 오래간다) 양방향성이 있다. 
연결을 만들고 유지하면서, 서버는 클라이언트에게 메시지들을 비동기적으로 보낼 수 있다.
클라이언트에서도 웹소켓을 사용하면 되기 때문에, 구현도 단순하고 직관적이다. 
js WebSocket을 사용해본 적이 있는데, 정말 간단한 방법으로 pub/sub 구조로 채팅이 가능하게 해준다.
어떤 id를 가진 소켓에 메시지를 보내면, 해당 소켓을 구독중인 클라이언트들에게 메시지를 보내줄 수 있다. <br> <br>

단, 이제 채팅 서비스는 Stateless하지 못 할 수도 있다. <br> 
각 클라이언트와 채팅 서버의 독립적인 연결을 유지해야 하기 때문이다. 서버측은 이 연결을 잘 관리해야 한다.


## 4. 저장소



<br>

채팅 데이터들은 어디에 저장하는 것이 좋을까? <br>
채팅 데이터들은 아래와 같은 특징을 가지고 있다.

![image](https://github.com/10000-Bagger/free-topic-study/assets/71186266/7e251e1e-cfa1-4eea-8667-d84237f15772)

<br>

1. 막대한 양의 데이터 <br> 페이스북은 이미 16년도에 매일 600억개 처리했다. 카카오톡도 19년도에 매일 100억건의 메시지를 처리했었다. 최근에 나온 카카오톡 알림톡은 23년도에 매일 1억건의 메시지를 발송했다. <br> **메시지 데이터는 그 크기가 어마어마하다.**
2. 최근의 메시지가 주로 읽힌다. -> 대부분의 유저는 오래된 메시지를 보지 않고, 최신 메시지를 읽는다.
3. 그래도 메시지 검색이나, 언급 (메시지 태그)등의 기능을 고려해 무작위적인 날짜-시간의 데이터 조회가 가능해야 함. (과거 데이터를 아주 안 보지는 않는다.)
4. 1:1 채팅 앱의 경우 읽기와 쓰기 비율은 1:1이다 <br> => 일반인 Application은 Read가 훨씬 비율이 높은데, Write도 클 수 있음을 고려해야함

<br>

이러한 상황에서, RDB보다는 NoSQL에 데이터를 저장하는 것이 권장된다.
그 중 Key-Value 저장소를 추천한다. 이유는 아래와 같다.

1. 수평적 규모 확장이 쉽다.
2. latency가 낮음
3. RDB는 데이터 중 long tail에 해당하는 부분을 잘 처리하지 못하는 경향이 있고, <br> 빠른 Random Access를 위해 인덱스가 있다면, 인덱스 비용이 너무 커질 수 있다. (데이터도 방대하고, Write가 많아서)
4. 페이스북과 디스코드와 같은 서비스가 실제로 사용 중이다 (안정성이 어느 정도 입증됐다?)

<br>

NoSQL에 채팅 데이터를 저장한다면, 빠른 속도로 데이터를 저장하고 읽을 수 있고, 규모 확장도 쉽다. <Br>
하지만, NoSQL을 사용할 때도 문제가 있다. <Br>

문제는 message들의 key값, id의 설정이다. 
보통 채팅 어플리케이션은 메시지의 정렬이 가능해야 한다. 그래서 key값은 유일하면서도 순서도 표현 가능하면 좋다.
예를 들어 방금 만들어진 메시지의 아이디가 k라면, 이후 만들어지는 메시지의 id는 k 보다 커야 한다는 뜻이다.
NoSQL에서는 보통 지원하지 않기 떄문에 [Twitter Snowflake ID](https://jeong-pro.tistory.com/251) 방식을 사용하면 좋다! (Data Warehouse 스노우 플레이크 솔루션이랑은 다른 것)

<br>

혹은, 채팅방 안에서만 순서가 유지되면 되니까, local sequence number generator를 이용한다. <Br> 
단순하게, 채팅방 레벨에서 ID를 시퀀셜 하게 유지하는 것이다.

<br> <br>


## 5. 설계

여러대의 채팅 서버를 운용하는 경우 로드밸런서는 아래와 같은 점들을 고려해 클라이언트에게 서버를 할당한다.

1. 클라이언트의 지리적 위치를 고려한다.
2. 서버의 용량을 고려한다. (현재 사용량)

주키퍼 Zoo Keeper와 같은 솔루션을 활용할 수 있다. 
단순히 아래 사진과 같이 진행된다. 앞서 언급한 조건들에 따라 유저에게 적절한 채팅 서버를 할당해 웹소켓 연결을 진행한다.

<br>

![image](https://github.com/10000-Bagger/free-topic-study/assets/71186266/4dbcef3a-b4b8-4abc-b428-2bed71f9fece)

<br>


## 6. 메시지 흐름

이제 종단간 메시지 흐름을 살펴보면서 앞서 언급한 내용들을 정리해보자. <br>
아래 3가지 흐름을 살펴볼 것이다
1. 1:1 채팅 메시지 처리 흐름
2. 여러 단말 사이의 메시지 동기화
3. 그룹 채팅 메시지 처리


<br>

## 6.1 1:1 채팅 메시지 처리 흐름
![image](https://github.com/10000-Bagger/free-topic-study/assets/71186266/c2c95d40-6182-42be-b9c3-d93e6c156597)

<br>

별거 없다.
1. 사용자 A가 로드밸런서에 의해 채팅 서버 1을 할당 받는다.
2. 메시지를 보낸다
3. 서버 1은 ID 생성기를 통해 메시지의 ID를 생성한다
4. 메시지는 동기화 큐로 보내진다.
5. 메시지는 Key-Value 저장소에 저장된다.
6. 이후 상대가 접속중이라면, 바로 접속중인 서버로 메시지를 보낸다.
7. 아니라면 푸시 알림 서버에 부탁해 알림을 보낸다.

<br>

별거 없다. 흐름이 정리되었을 것이다. 

<br>

## 6.2 여러 단말 사이의 메시지 동기화
각 단말마다 message current id 값을 갖는 것이 포인트이다. <br>
각 단말이 마지막으로 읽은 message의 id값을 보관해, 최신 메시지들이 있는 경우 가져온다.

<br>

![image](https://github.com/10000-Bagger/free-topic-study/assets/71186266/c0de8bfb-65f0-493a-8aea-c1a4c77602cf)

<br>

## 6.3 그룹 채팅 메시지 처리
소규모 일때는 유저마다 큐를 할당해 주는 것이 가능하다. WeChat이라는 App은 이런 접근을 위해 채팅방 인원을 500명으로 제한하고 있다.
하지만, 규모가 커지는 경우 이 수많은 똑같은 메시지들을 전부 큐에 복사하는 것은 결코 좋지 않다.


![image](https://github.com/10000-Bagger/free-topic-study/assets/71186266/1db6d4fe-9680-4793-ae52-475cef11a658)


<br>


## 끝
이 책에서는 더욱 하드한 트래픽 상황에서의 설명이 별로 없다. <br>
구체적인 기술이나 사례를 다음에 찾아서 공부해봐야 겠다. (채팅 시스템 있는 회사 기술 블로그 가면 널려있다.)
