
# 이벤트 스트리밍 플랫폼 쓰는 이유?
단순 MQ와 비교했을 때 kafka 같은거 쓰면서 기대되는 점은 <br> 
1. 데이터 장기 보관
2. 반복 소비

이 2가지이다. <br>

MQ의 순수한 목적은 메시지를 쌓아두는 것이다. <br>
kafka와 같은 이벤트 스트리밍 플랫폼에서 위 2가지를 지원해 주기 때문에, 상태 변화들을 추적할 수 있고, 필요할 시 특정 시점으로 부터 상태를 재현할 수 있다. 특히 Disk에 데이터를 써서 유실도 대비할 수 있고 좋은데, log처럼 append-only로 쓰면서 빠르게 쓰고, 빠르게 읽는다고 한다. (어떻게 빠를 수 있는건지 구체적인 방법이 궁금하다) <br> <br>

시스템 디자인을 공부하다 보면 kafka는 완전히 치트키.. 위에 적은 2가지 기능 외에도 정말 별의 별 것들을 알아서 도와준다. 
- 메시지를 디스크에 저장해 영속성이 있으면서도, log 같은 append-only 자료구조이기 때문에 디스크 헤드가 쬐끔만 움직여서 빠르다.
- 파티셔닝, Replication..
- 정확히 한번 전달 등의 보장..
- 분산 환경에서 이 모든 기능들과 생산자 소비자 그룹이 잘 상호작용 하도록 이런 저런 조율..
- 순서도 보장해 준다.

<br>

kafka, redis는 항상 치트키다. <br>
내가 궁금한건 kafka라는 단어는 빼고, 그래서 뭘 어떻게 도와줘서 치트키인건지 궁금하다. 왜 그런 니즈들이 나왔고 어떤걸 도와주는지 궁금하니까 책을 정리하면서 이것저것 알아보자.. <br>


# 메시지 모델과 기본 컴포넌트 용어들
## 1. 일대일 메시지 모델
큐의 메시지를 한 소비자만 가져갈 수 있는 모델. <br> 
한 소비자만 가져갈 수 있도록, 메시지를 가져갔다는 사실을 큐에 알리면 해당 메시지를 큐에서 삭제한다. <br>
이러한 모델은 Consumer Group - 소비자 그룹을 통해 지원할 수 있다. 

## 2. Pub/Sub 메시지 모델
발행-구독 모델은 특정 종류의 메시지를 관심있는 소비자들에게 모두(?) 전달할 때 사용한다. <br>
이는 topic 어떤 메시지에 topic이라는 일종의 주제를 부여하고, 주제별로 메시지를 보내 정리하고, 관심 있는 주제의 메시지를 받아본다. 어떤 주제에 메시지가 발행되면, 해당 주제를 구독한 소비자들에게 메시지가 전달되는 방식으로 구현된다. <br> 
유튜브에서 어떤 유튜브 채널이 새 영상을 만들면, 구독자들에게만 알림을 보내는 것과 비슷. <br>
메시지 큐에서 "토픽"의 이름은 유일하게 사용된다.

## 3. 파티션, 브로커
하나의 토픽에 보관되는 메시지가 너무나도 많으면 하나의 서버는 이를 감당하기 어려워진다. <br>
이를 위해 데이터를 샤딩할 수 있는데, **이를 토픽 파티션 분할이라고 부른다.** <Br>

토픽을 한 큐에 다 넣는게 아니고, 여러 파티션으로 분할해서 각 파티션에 균등하게 나눠 보내는 것이다. 이 파티션들은 큐 클러스터 내의 서버들에 고르게 분산 배치한다. <br>
`hash(key) & numPartitions`와 같은 공식으로 고르게 분산할 수 있다. (물론 다른 매커니즘도 얼마든지 가능하다) <br>

**이렇게 분산하는 것이 좋은 이유는 토픽의 용량 확장이 단지 파티션 갯수를 늘리는 것으로 끝나기 때문이다. 덕분에 높은 규모 확장성을 달성했따.**
<br>

- 주의1: 메시지 자체를 파티션에 고르게 분배하면서, 원래는 특정 토픽에 대해 전체 메시지의 순서가 보장 되었었는데, 이제 파티션 내에서만 유지된다. 
- 


# 4. Consumer Group
여러번 소비? "어디까지 읽었는지"는 누가 책임지나? 




# 5. 데이터 저장소
어떤 데이터 저장소를 활용해야 할까?

<br>

<!-- 이 목적을 달성하기 위해 데이터 저장소를 고려해보자. -->
<!-- - `회전 디스크(rotational disk)`: 디스크 기반 자료구조는 append-only 자료구조와 잘 어울린다. 높은 순차 탐색 성능을 보이고, 운영체제의 적극적 디스크 캐시 전략을 잘 활용할 수 있다. TODO: 찾아보기 -->
<!-- - 높은 대역폭을 위해 일괄처리도 가능하다. -->

<!-- - DB -->
<!-- - WAL -->


## 5.1 요구사항 정리
분산 메시지 브로커의 요구사항은 다음과 같다.
1. 데이터는 장기 보관될 수 있어야 한다.
2. 높은 대역폭을 제공해야 한다.

<br>

이 목적을 달성하기 위해 메시지 큐의 **트래픽 패턴을** 생각해보자.

1. 읽기/쓰기 연산이 빈번하게 발생
2. 읽기/쓰기는 순차적으로 이루어진다.
3. 메시지는 불변이다.

### 5.1.1 DB
단순한 선택지로는 DB를 사용할 수 있다. <br>
구체적으로 RDB의 경우엔 토픽별로 테이블을 만들 수 있고, 메시지는 레코드로 저장된다. 그리고 NoSQL의 경우 토픽별로 컬렉션을 만들고, 메시지는 하나의 문서로 취급된다. <br> 

1. 영속성이 있다.
2. 하지만, 대규모의 읽기/쓰기가 빈번한 상황을 잘 처리하지는 않는다. DB 보다 많은 데이터에 대한 읽기/쓰기가 빠른 저장소가 필요하다..

<br>

### 5.1.2 WAL(Write-Ahead Log)
쓰기 우선 로그는 "쓰기 연산"을 수행하기 전에 기록하는 로그로, MySQL에서는 트랜잭션 내에서 변경을 재현하기 위해 사용할 수 있는 Redo Log가 이 WAL이다. <br> <br>

지속성이 있고, Append-Only 형식의 일반 파일이기 때문에 순차적인 읽기/쓰기에 적합하다. 접근 패턴이 순차적이기 때문에 `회전 디스크(rotational disk)`는 아주 좋은 성능을 보인다. 높은 순차 탐색 성능을 보이면서도, 운영체제의 적극적 디스크 캐시 전략을 잘 활용할 수 있다. <br>
회전식 디스크 기반 저장장치는 저렴하기도 하다. <br> <br>

새로운 메시지를 파티션의 꼬리 부분에 추가하고, offset을 점진적으로 증가시킨다. log의 파일 줄 번호를 오프셋으로 사용할 수도 있지만, 파일의 크기는 무한으로 커질 수 없기 때문에 Segment 단위로 나누고, 활성 세그먼트에만 새로운 메시지 쓰기를 하는 방식으로 구성하면 될 것이다. <br>
그래서 이걸로 결정?

### 5.1.3 회전식 디스크가 느리다는 편견
각종 메모리를 활용한 성능 개선이나 Redis 덕분에, 회전식 디스크는 무조건 느린 무언가로 생각되곤 한다. <br>

하지만, 그것은 Random Access를 할 때 느린 것이다. 이리저리 회전하면서 



### 메시지 자료구조
키, 값
달라지면? -> 토픽을 새로 만들어

# 6. 일괄 처리 (batching)
메시지를 발행하고, 소비할 때 일괄 처리를 적용해 보자.

## 6.1 생산자 측 일괄 처리

생산자 측에서 메시지 브로커로 메시지를 보낼 때, 한번에 보내려면 어떻게 하면 좋을까... <br>

![Image](https://github.com/user-attachments/assets/ae6e3b16-3c65-44e4-96d2-d01c7564fe41)

<br> 


위와 같은 구성을 생각해보자.
1. 생산자는 메시지 생성
2. 라우팅 계층은 목적지를 확인하고, 어디로 보낼지 결정

<br>

이 경우 
1. 배치 처리를 하기 좋지 않다 -> 메시지를 어디에 저장할까.. 라우팅 계층?
2. 네트워크 홉이 하나 더 늘어난다 -> 다른 방법은 없는걸까?

<br>

![Image](https://github.com/user-attachments/assets/a8bc285f-de91-4701-aa67-cb29382517c5)

<br>

위와 같은 구성을 살펴보자. <br>
라우팅 계층을 생산자측 내부에 편입 시킨 구성이다. 이렇게 하면 장점이 있는데

1. 배치 처리가 용이하다. -> 생산자는 스스로 메시지를 얼마나 모으고 보낼지 결정할 수 있고, 생산자가 가진 버퍼에 메시지를 저장했다가 보낼 수가 있다.
2. 네트워크 홉 한번이 줄어든다. -> 생산자 내부에서 판단할 수 있음. 전송 지연 감소
3. 메시지가 어떤 파티션으로 갈지 자신만의 로직을 가지기 좋다.

## 6.2 소비자 측 일괄 처리

소비자측 일괄 처리는, 각 소비자가 메시지를 어디까지 가져갔는지 저장하는 offset값을 활용한다. offset 위치로 부터 시작해서 지정한 갯수의 메시지를 가져오면 된다. <br>


![Image](https://github.com/user-attachments/assets/db29a530-a2d7-40e8-b969-09919bba1c9e)



# 7. Pull Model vs Push Model
`소비자가 브로커에서 메시지 가져가기` vs `브로커가 소비자에게 메시지 보내기` <br>

둘 중 어떤 것이 적합할까?

### 배치처리의 경우 Pull Model이 더 적합하다.
![Image](https://github.com/user-attachments/assets/313efc33-8a9d-443a-8251-18c979bb6e1f)

Pull Model은 소비자가 알아서 메시지 브로커에서 메시지를 가져가는 것이다.

[장점]
1. 메시지 소비 속도를 소비자가 알아서 조절할 수 있다. -> 어떤 소비자는 하나씩 소비, 어떤 소비자는 batch로 소비..
2. 생산자와 소비자의 의존성이 낮다. -> 메시지 소비 속도가 생산 속도보다 느려질 때, 소비자를 늘리거나, 생산 속도를 따라잡을 때까지 기다릴 수 있다.
3. **소비자가 일괄처리 가능한 만큼의 메시지를 브로커에서 알아서 가져갈 수 있다.** Push 모델의 경우 브로커가 Consumer의 사정을 모른 채 메시지를 Push하기 때문에 소비자가 메시지를 바로 처리하기 어려운 상황이라면 버퍼에 잔뜩 쌓이게 된다.

<br>

[단점]
1. 브로커에 메시지가 없더라도 소비자가 계속해서 데이터를 끌어가려고 시도할 수도 있다. 쓸대없이 컴퓨터 자원을 낭비하지 않도록 **Long Polling을 사용할 수 있다.** -> pull 시도시 데이터가 없더라도 잠시 기다려 보는 것이다.

<br>

### 반면 Push Model은 batch 처리에 적합하지 않다. 

**브로커에서 메시지를 받자마자 소비자에게 보내는 방식인데,** 이렇게 하면 지연시간은 낮다는 장점은 있겠다. <br>

[단점]
1. 소비자의 메시지 처리 속도가 생산 속도보다 낮은 경우 소비자에 큰 부하가 걸리게 된다.
2. 메시지 큐를 넣는 장점 중 하나인, 컴포넌트별 스펙 의존도 낮추기가 무의미해 진다. -> 생산자가 데이터 전송 속도를 결정하기 때문에, 소비자는 항상 생산자에 맞춰 컴퓨팅 자원을 준비해야 한다.


# 컨슈머 리밸런싱 (재조정)
누가 어떤 파티션 소비할건지?
# 상태 저장소
offset 정보 등이 저장됨
## 메타 데이터 저장소
# 주키퍼
# 10. Replication

어떤 토픽의 파티션들은 여러 브로커 노드에 분산 되어 있다. <br>
그리고 파티션들의 Replica 또한 여러 브로커에 나누어 배치 되어 있다. <br>

![Image](https://github.com/user-attachments/assets/5a2e736f-6897-4f03-99c8-ed8b19df6546)

그림에서 진하게 칠해진 파티션이 Leader이고, 나머지가 Replica다. <br>

## 10.1 Replica 분산 계획
이런 Replica들을 어떤게 분산할지 기술하는 것이 `사본 분산 계획`, `Replica Distribution Plan`이다. 이 **사본분산 계획은 리더 브로커 노드가 리더로 선출될 때 만든다.** <br>
위 그림의 예시에선 아래와 같이 사본 분산 계획이 잡혀 있을 것이다.

1. `토픽-A 파티션-1`
    - 3개 Replica
    - `Leader`: 브로커-1
    - `Replica`: 브로커-2, 브로커-3
2. `토픽-A 파티션-2`
    - 3개 Replica
    - `Leader`: 브로커-2
    - `Replica`: 브로커-3, 브로커-4
3. `토픽-B 파티션-1`
    - 3개 Replica
    - `Leader`: 브로커-3
    - `Replica`: 브로커-1, 브로커-4

<br>

## 10.2 Replica 동기화
즐거운 Replica 동기화 시간 <br>
메시지는 리더로만 보내고, 리더가 Replica들에게 이 메시지를 동기화 시킨다. <br>
이 메시지를 단 하나도 놓치지 않는 방법은 무엇일까? **동기적으로 사본을 동기화 하는 것이다. 생산자가 메시지 브로커에 메시지를 넣을 때, 모든 사본이 동기화된 다음 응답을 주는 것이다.** <br>
- 문제: 좋다. 하지만 너무 느리다. 단 하나의 Replica라도 응답 지연이 발생한다면, 응답까지는 매우 오랜 시간이 걸릴 것이다.
- 

<!-- **"동기화된 사본" In-Sync Replicas - ISR은 리더와 동기화 된 사본을 일컫는 용어이다.** 리더와 동기화가 되었다고 보기 때문에, 리더 사망시 새로운 리더가 될 가능성이 있다 <br>
**"합의 오프셋" Committed Offset은 리더와 사본이 합의한 Offset으로, 이 Offset까지는 ISR 집합 내에 동기화가 끝났다는 것을 의미한다.** <br> -->


# 규모 확장성
- 생산자
- 소비자
- 브로커
- 파티션
# 메시지 전달 방식
# 메시지 필터링
# 메시지 지연 전송 및 예약 전송
# 소비 재시도
# 리더 선출 방식
