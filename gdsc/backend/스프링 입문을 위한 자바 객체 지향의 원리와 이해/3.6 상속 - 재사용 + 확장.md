# 3.6 상속: 재사용 + 확장
책의 앞 부분에서 짧게 언급하였듯이, 기존의 '상속'에 대한 비유는 우리의 객체지향성의 이해를 떨어트렸다. 으레, 상속을 설명 할 때면, 가계도를 그리곤 하였다. 때문에, 자연스럽게 가족 관계에서의 상속을 떠올리게 되며 많은 오해들을 낳았다. <br> 하지만 직접 객체지향성을 이용한 프로그램을 짜본 사람은 알 수 있었을텐데, 우리가 아는 그 상속과는 조금 의미가 다르다. <br> 객체 지향에서의 상속은 자식이 무언가를 물려 받는 개념으로 접근하기 보다는 **재사용과 확장의 개념으로 이해하는 것이 옳다.** 애초에 **자바 언어 자체에서 inheritance(상속)라는 키워드는 없다! extends가 있을 뿐이다!** 따라서, 가계도를 떠올리기 보다는 동불의 분류도를 떠올려야 한다. 

![3 6 inher](https://user-images.githubusercontent.com/71186266/192195515-87e24d00-d416-4c61-93b0-23ed207af2e9.png)

양서류는 변온척추동물의 자식이 아니다! 동물은 무척추동물의 부모가 아니다! 부모 자식의 관계라기 보다는 세분화와 일반화의 관계로 보는 것이 맞다. **객체지향에서의 상속은 상위 클래스의 특성을 하위 클래스에서 상속하는 것 뿐만 아니라, 필요한 특성을 추가-확장해서 사용할 수 있는 것이다.** <br>
이런 이해를 저하시키는 단어인 부모 클래스-자식 클래스라는 단어를 지양하자! <br> `상위 클래스 - 하위 클래스`, `슈퍼 클래스 - 서브 클래스`의 아름다운 용어가 있으니, 이를 애용하자. <br> <br> **상위 클래스로 갈 수록 추상화, 일반화 되었고, 하위 클래스로 갈 수록 구체화, 특수화가 되었다.**

## 3.6.1 하위 클래스는 상위 클래스이다. - is a kind of 관계
객체 지향의 상속 개념에서 아주 중요한 문장이다. <br> **하위 클래스는 상위 클래스이다.** 위의 그림에서, 양서류는 변온 척추 동물이고, 무척추동물은 동물이고, 조류는 정온동물이다. 이 멋진 문장은 후에 배울 LSP를 나타내는 말이다.

```java
변온동물 왕눈이 = new 개구리();
```
**쥐는 포유류이다.** 포유류 역할을 하는 미키마우스는 쥐이다. <br>
**상속은 is a kind of 관계를 가지고 있다.** <br>
- 팽귄 is a kind of 동물 (펭귄은 동물의 한 분류다.)
- 고래 is a kind of 포유류 (고래는 포유류의 한 분류다.)
- 조류 is a kind of 척추동물 (조류는 척추동물의의 한 분류다.)
 


## 3.6.2 상속과 인터페이스
자바는 다중 상속을 지원하지 않는데, 이는 <U>다중 상속 다이아몬드 문제 때문입니다.</U> 예를 들어 `인간` 클래스와 `거미` 클래스를 모두 상속 받은 스파이더맨이 있다고 가정합시다. 두 클래스에 중복된 메서드가 있다면, 둘 중 어느 곳의 메서드를 써야 할까요? <br> 이런 문제 때문에 자바에서는 다중 상속을 제거하는 대신 **인터페이스**를 도입하였다.  <br> <br>
클래스가 is a kind of 관계라면, 인터페이스는 **구현 클래스 is able to Interface**의 관계를 가지고 있다. 즉, **구현 클래스는 인터페이스 할 수 있다.** 와 같은 표현이 가능하다. <br> **인터페이스는 클래스가 '무엇을 할 수 있다'라고 하는 기능을 구현하도록 강제한다.** 즉, 일종의 메서드 **명세**입니다. <br> 자바 API의 인터페이스들도 이런 표현이 가능하다.
- Serializable: 직렬화할 수 있는
- Cloneable: 복제할 수 있는
- Comparable: 비교할 수 있는
- Runnable: 실행할 수 있는

## 3.6.3 상속 T 메모리
어떤 상위 클래스를 상속한 하위 클래스는 T메모리에 어떻게 나타날까?
아래의 예시로 살펴보자.
```java
public class Animal {
  public String name;
  public void sayName() {
    Sytem.out.println("나는 " + name + "\n");
  }
}

public class Mouse extends Animal {
  public String habitat;
  public void sayHabitat() {
        Sytem.out.println("나 " + habitat + "에 산다.\n");
  }
}

...

public class Main {
  public static void main(String[] args) {
    Mouse jerry = new Mouse();
    jerry.name = "제리";
    jerry.habitat = "톰 마음속";

    Animal micky = new Mouse();
    micky.name = "미키";
    // micky.habitat = "디즈니"
    // micky.sayHabitat();
  }
}
```
위와 같은 코드에서 T메모리는 아래와 같이 나타난다.

![3 6 T메모리](https://user-images.githubusercontent.com/71186266/192261584-23c870a5-204c-4446-96ae-823963f6ceee.png)

**힙 영역에 Mouse 클래스의 인스턴스가 만들어지면서 동시에, 상위 클래스인 Animal 클래스가 함께 만들어졌습니다.** 하위 클래스는, 인스턴스가 생성될 때 상위 클래스들의 인스턴스를 함께 만듭니다. <br> <br>

제리와 미키의 차이를 보자. 미키 객체 참조 변수는 Animal 형이기 때문에, Animal을 가르킨다. 결국 인스턴스는 둘 다 Mouse로 생성했지만, 객체 참조 변수의 자료형에 따라 다른 인스턴스를 가리킨다. <br> <br>

미키는 자신이 동물인 것만 인식하고 있고, 쥐인 것은 모른다. 때문에,  habitat를 지정할 수도, sayHabitat()를 사용할 수도 없다.


## 상속 정리
1. 객체 지향의 상속은 상위 클래스의 특성을 재사용하는 것이다.
2. 객체 지향의 상속은 상위 클래스의 특성을 확장하는 것이다.
3. 객체 지향의 상속은 is a kind of 관계를 만족해야 한다.

## Reference
- 동물 분류도: 세종검정고시학원 블로그 (http://blog.naver.com/bluesomedays)
